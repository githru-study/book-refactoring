# 12.10 서브클래스를 위임으로 바꾸기 Replace Subclass with Delegate

## 요약

상속만 사용하지 말고 컴포지션도 적절히 활용해라

## 배경

어떤 객체들이 갈래에 따라 다르게 동작한다면 상속을 사용할 수 있다. 그러면 공통 동작을 슈퍼클래스에 두고 다르게 동작해야 하는 부분을 서브클래스에 두어 구현할 수 있다.

상속의 단점은 다르게 동작해야 하는 이유를 단 하나만 가질 수 있다는 것이다. 그리고 슈퍼클래스와 서브클래스들이 긴밀하게 결합되기 때문에 슈퍼클래스를 수정할 때는 서브클래스들의 동작을 알고 있어야 한다.

슈퍼클래스가 가지고 있는 동작만으로는 불완전하고, 서브클래스가 오버라이드해 그 동작을 메꾸는 역할을 할 수도 있다. 이런 경우 슈퍼클래스가 서브클래스를 고려하지 않고 수정되면 서브클래스의 동작까지 망가질 수 있다.

이를 해결하기 위해 위임을 활용할 수 있다. 위임은 객체 간의 일반적인 관계이며, 인터페이스를 통해 상호작용한다. 위임은 상속보다 결합도가 훨씬 약하다.

우선 상속으로 접근한 다음, 문제가 발생하기 시작하면 위임으로 갈아탄다. 서브클래스를 상태 패턴이나 전략 패턴으로 대체하면 된다.

## 대상

- 상속을 사용하기 부적합할 때
    - 서브클래스를 구분해야 하는 이유가 여러가지가 될 때
    - 슈퍼클래스를 변경할 때 서브클래스의 영향을 받기 시작할 때

## 절차

1. 생성자를 호출하는 곳이 많으면 생성자를 팩토리 함수로 바꾼다
2. 위임으로 활용할 빈 클래스를 만든다.
    1. 생성자에서 서브클래스에 특화된 데이터를 전부 받는다
    2. 슈퍼클래스를 가리키는 역참조도 필요할 수 있다
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다
4. 서브클래스 생성 코드를 수정해 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다
    1. 이 과정은 팩터리 함수를 사용한다
    2. 생성자가 정확한 위임 인스턴스를 생성할 수 있다면 생성자에서 수행한다
5. 서브클래스 메서드 중 위임 클래스로 이동시킬 것을 고른다
    1. 필요하다면 메서드가 사용하는 원소도 옮긴다
6. 서브클래스 외부에서 원래 메서드를 호출하는 코드가 있따면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다
    1. 이때, 위임이 존재하는지 검사하는 보호 코드로 감싸야 한다
    2. 호출하는 외부 코드가 없다면 죽은 코드이므로 제거한다
    3. 둘 이상의 서브 클래스에서 위임 클래스를 뽑아낼 때, 위임 클래스 간에 중복이 생겨나기 시작했다면 슈퍼클래스를 추출한다. 위임 슈퍼클래스로 기본 동작이 옮겨졌다면 슈퍼클래스의 위임 메서드에는 보호 코드가 필요없다
7. 5~6을 반복해 서브클래스의 모든 메서드를 옮긴다
8. 서브클래스를 삭제한다

## 예시

1. 예약 클래스와 프리미엄 예약 클래스가 있다. 프리미엄 예약 클래스는 기본 예약 클래스의 동작을 따르면서 프리미엄 예약일 때 추가되는 동작을 분명히 하고 있다. 이러면 중복을 줄이고 서브 클래스에서 추가되는 동작을 한 눈에 알 수 있다.
2. 그런데 어떤 경우에는 상속이 적절하지 않을 수 있다
    1. 만약 예약이 프리미엄 예약으로 변경될 수 있다면, 객체를 새로 만들어야만 한다. 하지만 이 인스턴스가 여러 군데에서 사용된다면 모든 인스턴스를 교체하기는 어렵다.

https://github.com/githru-study/book-refactoring/pull/1

---
[목차](../README.md)
